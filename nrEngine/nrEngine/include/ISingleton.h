/***************************************************************************
 *                                                                         *
 *   (c) Art Tevs, MPI Informatik Saarbruecken                             *
 *       mailto: <tevs@mpi-sb.mpg.de>                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

/*!
 * \defgroup gp General purpose
 *
 * General purpose are classes or interfaces which can be used for a lot of
 * things. There is singleton implementation or dator interface. Just
 * read description of each class separatly you can find here.
 */

#ifndef _NR_I_SINGLETON_H_
#define _NR_I_SINGLETON_H_

//----------------------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------------------
#include "Prerequisities.h"
#include "Exception.h"


#if NR_COMPILER == NR_COMPILER_MSVC
// Turn off warnings generated by this singleton implementation
#   pragma warning (disable : 4311)
#   pragma warning (disable : 4312)
#endif

namespace nrEngine {

	//! All smart pointers created whithin this deleter could not be deleted outside
	/**
	* This is an null_deleter - deleter. We need this to create smart pointer
	* (SharedPtr<T>) from our singleton objects. Each pointer created with null
	* deleter can not be released otherwhere else here. So we can give smart pointer
	* to our singleton back and we can be sure, that our singleton object will not
	* be deleted before Release-Function will be executed
	* @see ::boost.org for smart pointers
	* \ingroup gp
	**/
	struct _NRExport null_deleter{
		void operator()(void const *) const
		{
		}
	};

	//! Singleton declaration used to prevent creating of more than one instance of a class
	/**
	* ISingleton class is used to define an object as an only one possible.
	* That means if you try to create new instance of this class there will be an error.
	* This is very usefull for objects like Kernel, FileSystem or something similar.
	* @note Thanks to: by Richard "superpig" Fine who get this from Scott Bilas (Game
	* Programming Gems) showing this technique in his tutorial about Enginuity.
	* \ingroup gp
	**/
	template<class Obj>
	class _NRExport ISingleton
	{

		protected:
			static Obj* _ms_singleton;//::boost::scoped_ptr<Obj> _ms_singleton;

		public:

			/**
			* Create a singleton object of the given instance
			*/
			ISingleton(){
				NR_ASSERT(_ms_singleton == NULL && "Instantiate: Singleton Object already created");
				#if defined( _MSC_VER ) && _MSC_VER < 1200
					int32 offset = (int32)(Obj*)1 - (int32)(ISingleton <Obj>*)(T*)1;
					_ms_singleton = (T*)((int32)this + offset);
				#else
					_ms_singleton = (static_cast< Obj* >( this ));
				#endif
			}

			/**
			* Delete the singleton object created before.
			**/
			virtual ~ISingleton(){
				//ISingleton<Obj>::Release();
				_ms_singleton = NULL;
			}


			/**
			* Access instance directly through -> operator. Can be overloaded
			**/
			virtual Obj* operator->(){
				return GetSingletonPtr();
			}

			/**
			* @return true if singleton object exists, false otherwise
			**/
			static NR_FORCEINLINE bool isValid(){
				return (_ms_singleton != NULL);
			}

			/**
			* @return smart pointer to our singleton
			**/
			static NR_FORCEINLINE const SharedPtr<Obj> GetSmartPtr(){
				SharedPtr<Obj> _ptr(GetSingletonPtr(), null_deleter());
				return _ptr;
			}

			/**
			* @return reference to singleton instance
			**/
			static NR_FORCEINLINE Obj& GetSingleton(){
				NR_ASSERT(_ms_singleton && "GetSingleton: No Singleton Object created until now");
				return *_ms_singleton;
			}

			/**
			* @return Pointer to singleton instance
			**/
			static NR_FORCEINLINE Obj* GetSingletonPtr(){
				NR_ASSERT(_ms_singleton && "GetSingletonPtr: No Singleton Object created until now");
				return _ms_singleton;
			}


			/**
			* Create the singleton instance of an object of type <i>Obj</i>
			**/
			static NR_FORCEINLINE void Instantiate(){
				//_ms_singleton.reset (new Obj());
				new Obj();
			}


			/**
			* Create the singleton instance of an object of type <i>Derived</i> which is
			* derived class of the <i>Obj</i> Base instance.
			* You ask here: Why we do it in this way?
			* So the answer is: You can so access to your base object. But it was
			* created from subclass. Usefull for example for objects which's base has
			* pure virtual functions.
			*/
			template<class Derived>
			static NR_FORCEINLINE void InstantiateAs(){
				//NR_ASSERT(_ms_singleton.get()==NULL && "InstantiateAs: Singleton Object already created");
				//_ms_singleton.reset (new Derived());
				new Derived();
			}

			/**
			* Release the instance and free used memory
			**/
			static NR_FORCEINLINE void Release(){
				//_ms_singleton.reset();
				if (_ms_singleton != NULL)
					delete _ms_singleton;
			}

	};

	template <class Obj>
	Obj*	ISingleton<Obj>::_ms_singleton = NULL;
	//::boost::scoped_ptr<Obj> ISingleton<Obj>::_ms_singleton(0);

}; // end namespace
#endif	//_NRCSINGLETON_H_
